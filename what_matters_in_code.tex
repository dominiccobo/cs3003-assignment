\section{What Matters In Code}

In the modern age of Software, companies live and die based on their ability to rapidly adapt to the changing environment in which they exist \parencite[Chapter~1]{kersten_2018}.

Companies increasingly direct their focus at the anatomy of project management, with a growing trend towards corporate agility \parencite{stateOfAgile_2019}; however, it is important to consider the role played by the construction quality of software.

Continuous Integration \parencite{duvall2007continuous} focuses on the importance of maintaining collaborative harmony, enabling rapid feedback on the co-existence of each change. Continuous Delivery \parencite{humble_farley_2010} expands on this and enables the small, rapid, incremental automated delivery of the software into each environment to further understand its impact. This makes it clear rapidly delivering change is key to successful software and companies; however, if its construction quality obstructs these changes, all the former will be of null effect.

Changing software is covered by Lientz and Swanson's five categories \parencite*{lientz1980software}. Kent Beck notes that preventative change is necessary to enable other maintenance: ``\textit{for each desired change, make the change easy (warning: this may be hard), then make the easy change}" \parencite{beck_2012_easychange}

Understanding what is preventing the easy change more objectively requires adopting some form of measurement. Consideration must be given as to whether we are measuring as a competitive benchmark for Project Management or as part of process or product improvement. Maintainability can be broken down into several areas: Testability, Understandability and Modifiability; each can be further broken down \parencite{Boehm:1976:QES:800253.807736}.

Aggregating several metrics to form a single aggregate metric, say Maintainability Index \parencite{bray1997c4} can risk obfuscating the intricacies of any areas necessitating improvement. Developers do not need to be told a piece of Software is bad or hard to work with; anthropological observation would suggest they know. Instead, understanding why it is hard to work with may allow for corrective and preventative improvements, ultimately yielding easier changes and a more fruitful future. Similarly, measuring anything but the desired outcome can risk ``gamification''; however, the notion of outcome is often contextually subjective. 

Kruchten et al \parencite*{kruchten2012technical} suggest that there may be an indicative correlation between code understandability and modifiability. Palomba et al \parencite*{palomba2018diffuseness} conclude that a focus on addressing certain code smells \parencite[chapter~3]{fowler1999refactoring} is likely to have a positive effect on change-proneness, but not on fault-proneness which seems to exist orthogonally. These conclusions seem to give light that acknowledging and acting on certain code-smells enable more maintainable code from the perspectives of understandability and modifiability. 

Software functionality is verified through testing; \textit{Testability} is the attribute defining the ability for a system to be tested.  Automated test suites serve an integral, irreplaceable role in the supply of rapid feedback for a changing system and can act as a safety net bolstering developer confidence.  Test suites serve as comprehensive living documentation for how a system should and should not work. 

Importantly it is key to focus on the human ability to innovate and solve logical problems, something which is cognitive taxing \parencite{sweller1998cognitive}. Ensuring developers have as many cognitive resources allocated as possible from a finite working memory to this task \parencite{miyake1999models}, we can guarantee constant innovative changes. 